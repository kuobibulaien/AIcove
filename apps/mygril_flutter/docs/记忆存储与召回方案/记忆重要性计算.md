# 记忆重要性计算（信息重要性 × 时间系数）

本文件只讨论“重要性怎么计算”，不讨论存储与召回流程（见 `记忆存储与召回方案.md`）。

---

## 1. 核心定义

把“重要性”拆成两部分（类比：先评“值不值得记”，再乘“放久会不会褪色”）：

- `infoImportance`：信息重要性（AI 打分为主，0~1）
- `timeCoef`：时间系数（系统自动维护，0.8~1）
- `importance = infoImportance * timeCoef`

特殊规则：
- **P=1（核心记忆）不受时间系数影响**：等价于 `timeCoef = 1`

---

## 1.5 施工提示（结合当前项目）

这部分只给“落地时放哪里算、谁来维护哪些字段”的方向，不写实现细节。

- AI 打分来源：当前总结入口在 `apps/mygril_flutter/lib/src/features/memory/services/memory_service.dart` 的 `summarizeAndStore()`；建议在那里把摘要输出扩展为包含 `E/I/P/J`（或由同一“记忆管理 AI”产出）。
- 系统维护字段（不交给 AI）：
  - `use_count`：仅当记忆被注入 prompt（topK=3）时 `+1`（入口在 `apps/mygril_flutter/lib/src/features/plugins/memory/memory_plugin.dart` 的 `getSystemPrompt()` 链路）
  - `last_active_at`：同上，命中时更新为 `now`
  - `timeCoef`：由系统按本文公式计算并落库（或实时计算），但必须保证范围始终在 `[0.8, 1.0]`
- 计算产物建议落库（便于排序与淘汰）：
  - `infoImportance`、`timeCoef`、`importance`
- P=1 的维护与冲突：
  - 不走自动合并规则，直接交给 AI 修改旧记忆内容（括号补丁），并在改写后重算 `infoImportance`（`timeCoef` 强制 1）

---

## 2. AI 需要输出的打分项（0~1）

### 2.1 `P` 持久性（最重要）

你给的标尺（必须写进评分准则）：
- `P = 1.0`：用户非常明确的喜好/厌恶（习惯、人格类），长期病痛  
  - 这类记忆需要维护：冲突由 AI 处理（修改旧记忆内容、加括号补丁，以用户最新为准）
- `P = 0.5`：用户长期计划（如健身减肥），或短期病痛（胃炎/肠炎）
- `P = 0.1`：很短期的生活流水（今晚吃了什么、买了什么）

### 2.2 `E` 情绪值（负面更高）

要求：负面权重更高（同强度下更“该记住”）。

建议做法（输出口径）：
- AI 输出一个 `valence ∈ [-1, 1]`（负面为负、正面为正）和 `intensity ∈ [0,1]`
- 系统转换为 `E`：  
  - `E = clamp(intensity * (valence < 0 ? 1.0 : 0.5), 0, 1)`

### 2.3 `I` 对话信息量（权重最低）

你定义为“任何新事实都算高分”，因此只能作为弱信号：
- 用来区分“有事实” vs “几乎没信息”
- 不能主导淘汰与保留

### 2.4 `J` 综合重要性（灵活性指标）

用途：给 AI 一个“方向盘”，处理公式难以覆盖的情况，例如：
- 信息可能很重要，但 P/E/I 量化困难
- 信息可能有误、风险高、需要谨慎记
- 需要把重要性拉高/压低做纠偏

注意：`J` 不应该变成“随意拍脑袋”。建议输出时附带一句非常短的理由（仅供日志/调试）。

---

## 3. 信息重要性 `infoImportance`（推荐权重）

默认权重（稳妥、可解释）：

`infoImportance = clamp(0.60*P + 0.20*J + 0.15*E + 0.05*I, 0, 1)`

解释：
- `P` 最大：决定“这条记忆是不是长期有用”
- `J` 次之：用于纠偏与策略灵活
- `E` 再次：负面更高，但不主导
- `I` 最低：因为“新事实普遍都高分”，只做微弱加成

---

## 4. 时间系数 `timeCoef`（系统维护，范围 0.8~1）

目标：
- 时间影响占比较低（0.8~1 之间变化）
- “用得越多”衰减越慢（你定义 useCount=被注入 topK 的次数）
- 以 `last_active_at` 为主（没有则用 `created_at`）

### 4.1 推荐公式（可调参，但必须落在 0.8~1）

定义：
- `ageDays = daysSince(last_active_at ?? created_at)`
- `u = use_count`
- `effectiveAge = ageDays / (1 + ln(1 + u))`

时间系数：

`timeCoef = 0.8 + 0.2 * exp(- effectiveAge / 30)`

直觉：
- 刚被用过（age≈0）：`timeCoef≈1`
- 很久没用：逐步趋近 `0.8`
- 用得越多：`effectiveAge` 更小，衰减更慢

P=1（核心记忆）：
- 强制 `timeCoef = 1`

---

## 5. 最终重要性 `importance`

`importance = infoImportance * timeCoef`

用途：
- 用于候选筛选（取前 300）
- 用于超额淘汰（>800 时从低到高送入回收站）

说明：
- 不额外引入“创建时间、最后活跃时间、使用次数”的复杂权重堆叠；它们已经通过 `timeCoef` 进入最终 importance。
- 若后续发现淘汰不符合直觉，再调整 `timeCoef` 的衰减速度即可（例如把 30 天改成 45 天）。

---

## 6. “时间戳输出”要求（给对话 AI 看）

你要求每条召回记忆都带相对时间，格式固定：

- `n天前的对话摘要“...”`

建议展示规则：
- `<1天`：`今天`
- `1~29天`：`{d}天前`
- `30~364天`：`{floor(d/30)}个月前`
- `>=365天`：`{floor(d/365)}年前`

重要约束：
- 不要求结构化抽取“事件发生时间”（因素太多）。  
  只要求总结 AI 在生成摘要时“注意对话中提到的事件发生时间（如果有）”，并把它写进摘要文本里。
