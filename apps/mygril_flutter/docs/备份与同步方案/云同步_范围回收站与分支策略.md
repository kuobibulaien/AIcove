# 云同步：范围清单 / 回收站 / 分支策略（含“重生成覆盖”规则）

面向：MyGril（Android/Windows 优先）  
目标：做“服务器端体验”的多端云同步，行为一致、可恢复、遇到冲突不丢数据。  

## 1. 总原则（你已确认）

1) **同步范围是全局一份**：用户勾选哪些内容参与同步（scope），所有设备都遵循同一份清单。  
2) **云端优先（Cloud wins）**：在允许同步的 scope 内，云端是权威来源，多端最终一致。  
3) **删除进入云回收站**：不立刻物理删除，保留一段时间后自动清除；可手动恢复。  
4) **冲突不硬合并**：遇到数据冲突就“新建一份”（保留两份，避免丢内容）。  

## 2. 消息不可编辑（核心约束）

### 2.1 规则
- **消息不支持编辑**：一条消息（message）一旦创建，内容（文本/blocks）不可被修改。  
- 允许更新的只有“状态类字段”：例如 `status=sending/sent/failed`、`delivered_at` 等（不改变内容）。  

### 2.2 为什么要这样做（通俗解释）
把消息当成“聊天里的发送记录”。如果允许随便改历史内容，两台设备很容易出现：
- A 改了某条历史消息；B 还没同步时又基于旧内容继续对话；
最终会像两个人拿着不同版本的聊天记录在对账，越对越乱。

不编辑消息，能让同步变成“只追加/少量删改状态”，稳定很多。

## 3. 修改消息的两种唯一方式

你提出的两种方式我们将明确成**两种不同语义**，并体现在同步/导出/回收站中。

### 3.1 方式 A：最后一条“重新生成”覆盖（参考 CherryStudio）

#### 行为定义
- 仅针对“最后一条 AI 回复（assistant）”提供 **重新生成**。
- 重新生成后，**用户视角**：新回复覆盖旧回复（旧回复在聊天里不再显示）。
- 工程实现建议（为了同步不出错）：
  1) 生成一条新消息 `newMsg`（新 id）
  2) 将旧消息 `oldMsg` 标记为“被替换/进入回收站”，并记录 `replaced_by = newMsg.id`

这样既满足“看起来覆盖”，又能让多端同步时：
- 知道旧消息为什么消失（不是莫名其妙丢了）
- 知道新消息和旧消息的关系（避免重复/错序）

#### 同步策略（云端优先）
- 重新生成应当作为一个“原子操作序列”落库并同步：
  - `tombstone(oldMsg)` + `insert(newMsg)`
- 多端拉取时：
  - 若发现某条消息 `replaced_by != null`，客户端隐藏旧消息，仅显示新消息。

> 注意：这不是“编辑 oldMsg”，而是“旧消息进回收站 + 新消息替换显示”。

### 3.2 方式 B：开分支（修改任意历史内容）

#### 行为定义
- 当用户想“修改历史”（不止最后一条重生成），必须创建一个**分支会话**。
- 分支会话是一个新的 conversation（新 id），并记录：
  - `parent_conversation_id`（来源会话）
  - `fork_from_message_id`（从哪条消息开始分叉）

#### 为什么要分支（通俗解释）
把它理解成“从某个时间点开始写另一条平行世界的聊天记录”。这样不会破坏原会话，也不需要做复杂合并。

#### 同步策略（云端优先）
- 分支会话是一个全新的对象：云端保存为独立会话，同步到所有设备。
- UI 呈现建议：分支在列表里像一个新聊天（可标注“来自 XXX 的分支”）。

## 4. 云回收站（删除/替换/清空的共同底座）

### 4.1 统一用“软删除 + 到期清理”
对所有可同步对象（会话、消息、角色卡、设置项等）使用：
- `deleted_at`：不为空表示在回收站
- `purge_at`：到期自动清除时间（= deleted_at + 保留天数）

保留天数：**固定 7 天（服务端代码常量）**。客户端只需要按 `purge_at` 展示“剩余时间/到期时间”即可。

### 4.2 恢复
恢复就是把 `deleted_at/purge_at` 置空（必要时记录一条 restore 操作日志）。

### 4.3 “清空会话”
清空本质是“批量软删除 messages/blocks”，会话本身可保留（只剩空壳）。

## 5. 冲突处理：不合并，直接“新建一份”

### 5.1 何时算冲突
常见冲突来源：
- 两台设备离线期间都对同一对象做了不兼容的变更（例如角色卡同时改名）
- 旧版本客户端重复上报导致版本回退

### 5.2 处理方式
云端发现冲突时：
- 保留原对象不动
- 复制生成一个新对象（新 id），并记录 `conflict_of = 原id`
- 两份都同步到所有设备，由 UI 提示用户（或默认为“新增一个同名项/分支项”）

这能保证“永远不丢数据”，代价是偶尔会看到重复项，但可控且可解释。

## 6. 同步范围（Scope）建议拆分

建议将“允许同步的白名单”拆成可勾选 scope（全局一份）：
- `chat.history`：聊天记录（conversations/messages/blocks）
- `characters.cards`：角色卡/联系人资料（头像、人设、称呼、立绘等）
- `characters.per_settings`：某个角色的单独设置（置顶/收藏/免打扰/提示音/默认 provider 等）
- `providers.config`：渠道商配置（baseUrl、capabilities、customConfig、启用状态、可见模型）
- `providers.keys`：渠道商 key（体验优先：账号云同步）
- `user.text_inputs`：用户手填文本类（昵称/备注/自定义提示词等，按字段归类）

不在白名单内的内容：保持本地，不参与云同步（例如下载目录、通知权限状态、缓存等）。

## 7. 导入/导出：跟随同一份 Scope 清单

### 7.1 默认导入（低风险）
- 只导入 scope 清单里勾选的部分
- 默认“合并”：
  - 远端/备份多出来的对象：保留（追加）
  - 已存在且冲突：按“新建一份”策略（避免覆盖导致丢数据）

### 7.2 高风险选项：完全覆盖
- 用户手动勾选后：对所选 scope 执行覆盖（适合把本机变成“另一台一模一样”）

## 8. 待定参数（实现前最后确认）

1) 云回收站保留天数：**固定 7 天（服务端代码可改）**  
2) “最后一条重新生成”限定范围：仅 assistant？是否允许对“最后一条用户消息”做重发？（默认否）  
3) 冲突副本的 UI 呈现：对话列表标注 / 分支标注 / 回收站标注  

---

## 9. 施工入口（给“动工 AI”看的）

本文件描述“同步行为规则”。真正的施工手册（包含：最终数据模型/表字段、HTTP 接口、增量同步流程、幂等与冲突判定、备份格式、渠道商 Key 同步与服务端一次性密钥加密方案）在：
- `apps/mygril_flutter/docs/备份与同步方案/施工手册_备份与云同步.md`
