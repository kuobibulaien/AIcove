# 施工手册：备份与云同步（可直接交给另一个 AI 开工）

面向：负责“真正动工写代码”的开发者/AI  
约束：你**看不到**我和用户的聊天记录，请完全按本手册实现，不要自作主张改规则。  
范围：Android/Windows 优先；Web 不作为目标平台。  

---

## 0. 一句话目标（做成 Telegram 那种体验）

用户登录后：聊天记录、角色卡、用户手填文本、渠道商配置（含 key）、角色单独设置等，在多端**自动云同步**；删除进云回收站 7 天；历史不做编辑，想“改历史”就开分支；仅“最后一条 AI 回复”支持重生成，用户视角覆盖旧回复。

---

## 0.5 现有项目改造指南（重要：别推倒重来）

你接手的是一个“已经能跑起来”的项目，它的现状和目标架构不完全一致。为了避免动工时推翻现有代码导致风险爆炸，必须按“加一层、逐步替换”的方式改。

### 0.5.1 当前真实现状（你必须先对齐）

1) **Flutter 端聊天持久化目前是 SharedPreferences 的整包 JSON**
- 入口文件：`apps/mygril_flutter/lib/src/features/chat/providers2.dart`
- 关键点：`ConversationsNotifier` 使用 key `mygril.conversations` 读写“会话+消息+blocks”的一坨 JSON
- 影响：数据越多越卡、难做分页/索引、难做增量同步与回收站/分支/重生成覆盖

2) **后端已具备部分同步基础，但不满足本手册目标**
- 你会看到 `cloud_backend` 已有 contacts/messages/settings/memory 等相关模型/接口
- 但缺少：scope 全局清单、聊天增量 pull/push、回收站字段、冲突新建、分支会话、最后一条重生成覆盖、providers(keys) 的加密托管等

3) **Flutter 端已有“设置/渠道商”体系（不是从零开始）**
- 项目里已存在 providers 配置与 key 的数据结构与读写逻辑（具体位置以代码检索为准）
- 动工时应当把它纳入“scope 过滤 + 云端优先”框架，而不是重写一套互不兼容的新设置系统

### 0.5.2 推荐改造路线（按风险从低到高）

#### Step A：先做云端（让“云端优先”成立）
目标：即使客户端暂时还在用 SharedPreferences，也能“登录→自动拉取→展示一致数据”。
- 新增/完善：`sync_scopes` 下发（全局一份）
- 新增/完善：增量同步（pull/push + cursor）
- 新增/完善：回收站（deleted_at/purge_at，固定 7 天）
- 新增/完善：冲突新建（conflict_of）
- 新增/完善：分支会话（parent_conversation_id/fork_from_message_id）
- 新增/完善：最后一条重生成覆盖（replaced_by，事务原子）
- 新增/完善：providers(keys) 服务端托管 + 信封加密落库（一次性 DEK）

#### Step B：客户端先加“同步引擎层”（先别动 UI）
目标：把“云端变化”稳定落到本地缓存，把“本地操作”稳定上报云端，但 UI 结构暂不大改。
- 新增一个 SyncService/SyncEngine（命名自定）
- 登录后：按 scope 拉取云端变化 → 落本地缓存 → 刷新现有 Provider
- 本地发生操作：生成 op_id → push 上报 → 拿到新 cursor

> 这一步的关键是：不要一上来就把 UI/Provider 全部推倒重写。先让同步跑通，确保行为符合回收站/分支/重生成覆盖规则。

#### Step C：最后再替换 SharedPreferences 的聊天存储为 SQLite/Drift
目标：解决性能与可维护性（分页/索引/大数据量），并让备份导入导出有稳定底座。
- 将 `ConversationsNotifier` 的持久化从 SharedPreferences 切换到 Repository（读写本地 SQLite）
- 做一次性迁移：检测 `mygril.conversations` → 导入 SQLite → 成功后删除旧 key

### 0.5.3 关键文件落点（让你知道从哪动手）

Flutter 端：
- `apps/mygril_flutter/lib/src/features/chat/providers2.dart`
  - 负责：对话列表/消息列表状态 + 当前 SharedPreferences 持久化入口
- `apps/mygril_flutter/lib/src/features/chat/data/session_manager.dart`
  - 负责：会话结束触发（记忆摘要/触发器/主动消息）；不直接存储，但会影响“什么时候触发同步/汇总”

后端：
- `cloud_backend/sync_api.py`
  - 负责：同步 API 入口（可扩展为本手册定义的 scopes/pull/push）
- `cloud_backend/models.py`
  - 负责：云端表结构（需要加入回收站/分支/替换/冲突相关字段，及 providers 表与加密封装）

---

## 1. 名词表（避免理解偏差）

- **Cloud wins（云端优先）**：在“允许同步”的范围内，云端是权威来源；多端最终一致。
- **Scope（同步范围）**：一份“全局勾选清单”，决定哪些数据参与同步；所有设备遵循同一份。
- **软删除/回收站**：对象被删除后写 `deleted_at/purge_at`，保留 7 天后物理清理；可恢复。
- **冲突新建**：不同设备的变更冲突时不硬合并，复制出“冲突副本”（新 id），两份都保留。
- **分支会话（fork/branch）**：从某条消息起分叉出一个新 conversation（新 id），形成平行世界对话。
- **重生成覆盖（regen replace）**：只针对“最后一条 assistant 消息”，生成一条新消息并让旧消息进入回收站，UI 只显示新消息。

---

## 2. 顶层规则（必须严格遵守）

### 2.1 同步范围是全局一份
- 云端保存一份 `sync_scopes`（白名单内可勾选项），所有设备登录后拿到同一份。
- 客户端不允许“每台设备一套不同 scope”，否则无法稳定收敛。

### 2.2 云端优先的边界
- **在 scope 内**：云端优先（Cloud wins），客户端最终要与云端一致。
- **不在 scope 内**：本地自管，云端不存也不下发（例如：下载目录、通知权限状态、缓存等设备相关项）。

### 2.3 消息不可编辑
- message 内容（content/blocks）创建后不可修改。
- 允许更新的只有状态类字段（sending/sent/failed 等），不改变内容。

### 2.4 修改历史内容只能走两条路
1) **最后一条 assistant**：允许“重生成覆盖”（不是编辑，是替换显示 + 旧消息进回收站）。  
2) **其他任何历史**：必须“开分支会话”，原会话不动。

### 2.5 删除进入云回收站（固定 7 天）
- 服务端常量：回收站保留 7 天（可改代码，但当前按 7 天实现）。

---

## 3. Scope 设计（同步范围清单）

### 3.1 可勾选 scope（全局一份）
建议按以下字符串常量定义（用于服务端存储 + 客户端展示 + 备份导入导出勾选）：
- `chat.history`：聊天记录（conversations/messages/message_blocks）
- `characters.cards`：角色卡/联系人资料（头像、人设 prompt、称呼、自称、立绘、voice 等）
- `characters.per_settings`：单角色设置（置顶/收藏/免打扰/提示音/默认 provider 等）
- `providers.config`：渠道商配置（baseUrl、capabilities、customConfig、启用状态、可见模型等）
- `providers.keys`：渠道商 key（体验优先：账号自动携带并同步）
- `user.text_inputs`：用户手填文本类（昵称/备注/自定义提示词等，按字段归类）

### 3.2 Scope 与数据对象映射（你必须按此过滤同步/备份）
实现时必须做到：
- scope 未勾选 → 对应数据不上传、不下发、不导入、不导出。
- scope 已勾选 → 对应数据参与云同步与备份。

---

## 4. 数据模型（最终定稿版，动工按这个落库）

说明：本项目采用“云端优先”，本地 SQLite 作为缓存/离线/导入导出底座。  
因此建议云端与本地的字段尽量一致（减少映射），但允许云端多一些审计字段（例如 user_id）。

### 4.1 conversations（会话/联系人/角色卡 + 会话摘要）
用途：对话列表页秒开 + 角色卡信息 + 单角色设置（可拆 scope）

核心字段（建议）：
- `id` TEXT PRIMARY KEY（UUID）
- `title` TEXT NOT NULL
- `display_name` TEXT NOT NULL
- `avatar_url` TEXT NULL
- `character_image` TEXT NULL（本地相对路径或云端资源 key）
- `self_address` TEXT NULL
- `address_user` TEXT NULL
- `voice_file` TEXT NULL
- `persona_prompt` TEXT NOT NULL DEFAULT ''
- `default_provider` TEXT NULL
- `session_provider` TEXT NULL
- `is_pinned` INTEGER NOT NULL DEFAULT 0
- `is_favorite` INTEGER NOT NULL DEFAULT 0
- `is_muted` INTEGER NOT NULL DEFAULT 0
- `notification_sound` INTEGER NOT NULL DEFAULT 1
- `last_message` TEXT NULL（缓存字段）
- `last_message_time` INTEGER NULL（缓存字段，unix ms）
- `unread_count` INTEGER NOT NULL DEFAULT 0
- `parent_conversation_id` TEXT NULL（分支来源）
- `fork_from_message_id` TEXT NULL（分支起点）
- `conflict_of` TEXT NULL（冲突副本来源 id）
- `deleted_at` INTEGER NULL（回收站）
- `purge_at` INTEGER NULL（回收站到期时间）
- `created_at` INTEGER NOT NULL
- `updated_at` INTEGER NOT NULL

索引建议：
- `idx_conv_updated(updated_at DESC)`
- `idx_conv_pinned(is_pinned DESC, updated_at DESC)`
- `idx_conv_parent(parent_conversation_id)`
- `idx_conv_deleted(deleted_at)`

Scope 映射：
- `characters.cards`：角色卡字段（头像、人设、称呼、voice 等）
- `characters.per_settings`：is_pinned/is_favorite/is_muted/notification_sound/default_provider/session_provider
- `chat.history`：会话壳（id/title/created/updated）+ last_message 缓存（可选，但推荐同步）

### 4.2 messages（消息）
用途：聊天页分页加载；消息不可编辑（内容不更新）

字段：
- `id` TEXT PRIMARY KEY（UUID）
- `conversation_id` TEXT NOT NULL
- `role` TEXT NOT NULL（'user'|'assistant'，如未来有 system/tool 可扩展）
- `content` TEXT NOT NULL（fallback 预览文本，可由 blocks 拼接得来）
- `status` TEXT NOT NULL DEFAULT 'sent'（'sending'|'sent'|'failed'）
- `replaced_by` TEXT NULL（重生成覆盖：旧消息指向新消息）
- `conflict_of` TEXT NULL
- `deleted_at` INTEGER NULL
- `purge_at` INTEGER NULL
- `created_at` INTEGER NOT NULL

约束/索引：
- FOREIGN KEY(`conversation_id`) REFERENCES conversations(id) ON DELETE CASCADE（注意：SQLite 必须启用外键）
- `idx_msg_conv(conversation_id, created_at DESC)`
- `idx_msg_deleted(deleted_at)`
- `idx_msg_replaced(replaced_by)`

Scope 映射：
- `chat.history`：messages 全部

### 4.3 message_blocks（多模态块）
用途：一条消息的结构化内容（文本/图片/音频/表情等）

字段：
- `id` TEXT PRIMARY KEY（UUID）
- `message_id` TEXT NOT NULL
- `type` TEXT NOT NULL（'mainText'|'image'|'audio'|'emoji'|'tool'|'thinking'...）
- `status` TEXT NOT NULL DEFAULT 'success'（'pending'|'success'|'error'）
- `data` TEXT NOT NULL（JSON，见 4.6）
- `sort_order` INTEGER NOT NULL DEFAULT 0
- `created_at` INTEGER NOT NULL

约束/索引：
- FOREIGN KEY(`message_id`) REFERENCES messages(id) ON DELETE CASCADE
- UNIQUE(`message_id`, `sort_order`)
- `idx_block_msg(message_id, sort_order)`

Scope 映射：
- `chat.history`：message_blocks 全部

### 4.4 providers（渠道商配置 + key）
说明：这是“用户手动输入的渠道商信息”，你要求体验优先，**账号自动携带并多端同步**。

强烈建议：providers 不要塞进一个大 JSON 里；要么单表存多行，要么云端用表、本地可缓存为表/JSON 都行，但字段要能增量同步。

字段（建议）：
- `id` TEXT PRIMARY KEY（providerId）
- `display_name` TEXT NOT NULL
- `api_base_url` TEXT NOT NULL
- `enabled` INTEGER NOT NULL DEFAULT 1
- `capabilities` TEXT NOT NULL DEFAULT '[]'（JSON array）
- `custom_config` TEXT NOT NULL DEFAULT '{}'（JSON object）
- `model_type` TEXT NULL
- `visible_models` TEXT NOT NULL DEFAULT '[]'（JSON array）
- `hidden_models` TEXT NOT NULL DEFAULT '[]'（JSON array）
- `api_keys` TEXT NOT NULL DEFAULT '[]'（JSON array，注意：云端落库要求加密，见第 7 章）
- `conflict_of` TEXT NULL
- `deleted_at` INTEGER NULL
- `purge_at` INTEGER NULL
- `created_at` INTEGER NOT NULL
- `updated_at` INTEGER NOT NULL

Scope 映射：
- `providers.config`：除 `api_keys` 外所有字段
- `providers.keys`：`api_keys`

### 4.5 user_settings（其它全局设置）
说明：用户希望“多端不重新调”。建议做成“设置项字典”或拆表。

最稳的工程做法（便于 scope 过滤 + 增量同步）：
- `settings_kv` 表：`key/value/updated_at`（value 为 JSON）

如果你要沿用后端现有 `user_settings.settings_json`，也可以，但要补：
- `sync_scopes`（全局一份的勾选清单）
- `updated_at/version`
- 加密封装（若包含 providers.keys，一定要按第 7 章）

Scope 映射：
- `user.text_inputs`：只同步“用户直接输入的文本类”设置键（由产品白名单决定）
- 设备相关设置键：禁止同步

### 4.6 message_blocks.data（JSON 规范，必须统一）
为了跨端/备份/同步稳定，blocks 的 JSON 必须版本化：

通用结构：
```json
{
  "v": 1,
  "payload": { }
}
```

约定：
- `v`：版本号（后续结构变更靠它做迁移/兼容）
- `payload`：不同 type 的内容

示例（TextBlock）：
```json
{ "v": 1, "payload": { "text": "你好" } }
```

示例（AudioBlock，附件路径必须相对路径或云端 key）：
```json
{
  "v": 1,
  "payload": {
    "url": "file:audio/tts/abc.m4a",
    "text": "语音对应字幕（可选）"
  }
}
```

附件路径规则（本地）：
- 数据库/备份里只存“相对路径或资源 key”，禁止存绝对路径。

---

## 5. 同步协议（HTTP 接口，施工必须按此实现）

说明：你可以实现为 REST 或 WebSocket，但至少要满足：增量拉取、幂等上报、回收站、冲突新建、分支、重生成覆盖。

### 5.1 版本与幂等（基础设施）
客户端必须提供：
- `device_id`：设备标识（安装时生成并持久化）
- `op_id`：每次写操作的幂等 id（UUID），避免重试导致重复写

服务端建议维护：
- 每类资源的 `updated_at`（ms）或 `version`（单调递增）
- 对同一 `op_id` 的重复请求：返回同样结果（幂等）

### 5.2 Scope 下发（全局一份）
- `GET /sync/scopes`
  - 返回：当前账号的 scope 勾选清单 + `updated_at`
- `PUT /sync/scopes`
  - 仅允许写“白名单内”scope；写入后更新 `updated_at`

> scope 是“全局一份”，不要做成设备维度。

### 5.3 增量同步总入口（推荐）
实现一个聚合接口，减少移动端并发请求：
- `GET /sync/pull?since=<cursor>`
  - 返回：在 `since` 之后变化的所有资源（按 scope 过滤）
  - cursor 可以是时间戳或服务端生成的同步游标（建议游标）

同时提供：
- `POST /sync/push`
  - body：一组操作（append message / delete / restore / regen / fork / update provider / update character card 等）
  - 服务端按 op_id 幂等执行，并返回新的 cursor

### 5.4 资源级接口（如果你不做聚合）
至少需要：
- conversations：
  - `GET /sync/conversations?since=...&include_deleted=1`
  - `POST/PUT /sync/conversations`
- messages：
  - `GET /sync/messages?conversation_id=...&before=...&limit=...`
  - `GET /sync/messages/changes?since=...&include_deleted=1`
  - `POST /sync/messages`（追加）
- message_blocks：
  - `GET /sync/blocks?message_id=...`
- providers：
  - `GET /sync/providers?since=...&include_deleted=1`
  - `PUT /sync/providers`（增删改）
- settings：
  - `GET /sync/settings?since=...`
  - `PUT /sync/settings`

---

## 6. 操作语义（最容易写错，必须按此实现）

### 6.1 追加消息（append）
前提：消息不可编辑，所以客户端只会“追加新消息”。

服务端处理：
- 插入 messages + blocks（同一个事务）
- 同步更新 conversations 的 `last_message/last_message_time/updated_at`

### 6.2 删除（delete → 回收站）
对任意对象（conversation/message/provider/character card 等）：
- `deleted_at = now`
- `purge_at = now + 7 天`

### 6.3 恢复（restore）
- `deleted_at = null`
- `purge_at = null`

### 6.4 清空会话（clear conversation）
本质：批量软删除该会话的 messages/blocks（会话壳保留）。

### 6.5 最后一条 assistant 重生成覆盖（regen replace）
约束：
- 只能对“某会话最后一条 assistant 消息”执行
- 不是编辑旧消息

服务端原子序列（同一个事务）：
1) 将旧消息 `oldMsg` 软删除（进回收站），并写 `replaced_by = newMsg.id`
2) 插入新消息 `newMsg` + blocks
3) 更新 conversations 的 last_message 缓存

客户端展示规则：
- 拉取到 `replaced_by != null` 的 oldMsg：隐藏 oldMsg，仅显示 newMsg
- 回收站里可见 oldMsg（可选是否展示“被替换”标记）

### 6.6 开分支会话（fork）
约束：
- 用户想修改历史内容（非最后一条重生成）→ 必须 fork

服务端创建新 conversation：
- `id = new`
- `parent_conversation_id = 原会话 id`
- `fork_from_message_id = 分叉起点消息 id`
- 初始消息可复制“分叉点之前的上下文”或只存引用（由产品决定；建议复制到分支，减少依赖）

### 6.7 冲突处理（conflict → 新建）
云端检测到冲突时（例如同一对象基于旧 version 的不同更新）：
- 不覆盖原对象
- 复制生成新对象（新 id）
- 新对象 `conflict_of = 原id`
- 两份都同步下发

---

## 7. 渠道商 Key 同步与“动态一次性 key”加密（体验优先版本）

目标：账号自动携带 key，多端无感同步；同时避免数据库明文存储。

### 7.1 方案：服务端信封加密（Envelope Encryption）
服务端维护一个长期主密钥（KEK，来自配置/密钥管理系统）。  
每次写入敏感数据（例如 providers.api_keys 或包含 key 的 settings）时：
1) 生成一次性数据密钥 `DEK`（每次更新都不同）
2) 用 `DEK + AES-256-GCM` 加密明文 payload（例如 providers.api_keys 或整段 settings_json）
3) 用 `KEK` 将 `DEK` 包装（wrap）后与密文一起存库

落库建议存成 JSON 信封（示例）：
```json
{
  "v": 1,
  "cipher": "AES-256-GCM",
  "dek_wrap": "KEK-AES-GCM",
  "nonce": "...base64...",
  "ciphertext": "...base64...",
  "tag": "...base64...",
  "wrapped_dek": "...base64..."
}
```

读取时服务端解包即可下发明文给客户端（体验优先），或下发密文由客户端解密（若未来想升级 E2EE）。

### 7.2 重要提醒（你必须实现到位）
- 传输仍依赖 HTTPS/TLS
- 落库必须是密文（避免数据库泄露时直接暴露 key）
- 每次更新生成新 DEK（满足“动态 key 只用一次”）

---

## 8. 离线导出（用户静态密钥加密备份文件）

目标：用户在“导出聊天记录/设置”时，输入一个静态口令，用来加密备份包；导入时再输入口令解密。

### 8.1 备份 zip 结构（必须固定）
`mygril_backup_YYYYMMDD.zip`
```
manifest.json
data/
  conversations.json
  messages.json
  message_blocks.json
  providers.json
  settings.json
assets/
  avatars/
  images/
  audio/
```

### 8.2 manifest.json（必须包含）
```json
{
  "version": "1.0",
  "export_time": "2025-12-25T10:30:00Z",
  "scopes": ["chat.history", "providers.keys"],
  "encryption": {
    "enabled": true,
    "kdf": "PBKDF2-HMAC-SHA256",
    "iterations": 200000,
    "salt": "base64...",
    "cipher": "AES-256-GCM"
  },
  "files": {
    "data/conversations.json": { "sha256": "..." }
  }
}
```

### 8.3 加密规则（离线口令）
- 使用 PBKDF2 从口令派生密钥（salt + iterations 写进 manifest）
- 使用 AES-256-GCM 加密敏感文件（至少 providers.keys / settings 中的 key 部分）
- 可以选择“整包加密”或“只加密敏感 json”

### 8.4 导入策略（按 scope 过滤）
导入 UI 必须提供：
- 默认：合并（保留新增；冲突→新建）
- 高风险：完全覆盖（对选中 scope 的数据覆盖本地）

---

## 9. 本地 SQLite（Drift）落地要点（只写原则，不写代码）

本地库用途：
- 离线可用 / 加速 UI / 作为导入导出的底座
- 同步引擎把云端变化落到本地缓存

关键约定：
- SQLite 必须启用外键：`PRAGMA foreign_keys = ON`
- 建议 WAL：`PRAGMA journal_mode = WAL`
- 大批量写入（迁移/导入/同步落盘）必须事务 + 批处理
- 附件路径只存相对路径或资源 key（禁止绝对路径）

---

## 10. 施工顺序（推荐，不要乱跳）

1) **后端先行**：确定云端表结构（含 deleted_at/purge_at/conflict_of/replaced_by/parent/fork 字段）  
2) 实现 scope 下发（全局一份）  
3) 实现云回收站（软删除 + 7 天到期清理 + restore）  
4) 实现消息追加 + 最后一条重生成覆盖（原子事务）  
5) 实现分支会话（fork）  
6) 实现 providers 配置与 key 同步（含服务端信封加密）  
7) 实现增量同步（pull/push + 幂等 op_id + cursor）  
8) 客户端：本地 Drift 缓存 + 同步引擎 + UI 读取缓存  
9) 导入/导出：按 scope 过滤 + 离线口令加密  

---

## 11. 验收清单（做完就算对）

- 两台设备登录同一账号：新增消息/删除/恢复/分支/最后一条重生成，在另一端都能正确出现  
- 删除后 7 天内能从回收站恢复；7 天后自动清理（不可恢复）  
- 重生成后：旧消息不再显示，新消息替代显示；旧消息能在回收站找到（或至少可追溯）  
- 修改历史：只能创建分支会话，原会话不变  
- providers key：多端自动同步；数据库落地为密文（服务端信封加密）  
- 导出：按 scope 勾选导出；加密备份导入需口令；默认合并，冲突新建；可选完全覆盖  
